---
name: engineering-from-architecture
description: Чтение и интерпретация архитектурных решений для реализации в коде. Применять при инженерных работах, реализации задач из ENGINEER_TASKS, интерпретации диаграмм и контрактов, соблюдении архитектурных границ, работе с зависимостями между task_id. Универсальный скилл — активен для любого TASK_DOMAIN.
---

# Чтение и интерпретация архитектурных решений

## Порядок чтения architect_output.md

1. **Обзор решения** — понять намерение, не детали
2. **Диаграмма** — определить слои, направления зависимостей, границы модулей
3. **Типы и контракты** — священный контракт, не нарушать
4. **ENGINEER_TASKS** — найти свою `task_id`, прочитать `description` и `files_scope`
5. **Разделение труда → «Для инженера»** — только эта секция является зоной ответственности

## Работа с task_id в ENGINEER_TASKS

Каждый инженер работает только со своей `task_id`:

```yaml
- task_id: auth-hook
  description: Реализовать хук useAuth с логикой токена
  complexity: high
  dependencies: []
  files_scope:
    - src/hooks/useAuth.ts
    - src/services/authService.ts
```

- Работай **только с файлами из `files_scope`**
- Не выходи за пределы своей `task_id`
- Если нужны файлы вне `files_scope` — это повод для блокера

## Когда создавать блокер вместо кода

Создавай `engineer_tasks/<task_id>_blocker.md` вместо реализации если:

- **Тип/интерфейс не определён** в `architect_output.md` — не придумывай
- **Связь есть на диаграмме, но контракт не описан** — не угадывай сигнатуры
- **Архитектурное решение противоречит существующему коду** — не выбирай сторону
- **`files_scope` не соответствует описанию задачи** — scope-mismatch

## Интерпретация диаграмм

| Элемент | Значение |
|---------|----------|
| `A → B` (сплошная) | A зависит от B — прямая зависимость (импорт, инстанцирование) |
| `A -.-> B` (пунктирная) | Слабая связь — через интерфейс или событие |
| Граница/контур вокруг группы | Изолированный модуль; внутреннее не экспортируется наружу |
| `subgraph` | Слой или bounded context — общение только через публичный API |

## Работа с зависимостями между task_id

Если твоя задача имеет `dependencies: [other-task-id]`:

1. Оркестратор гарантирует, что зависимая задача завершена до твоего запуска
2. Убедись, что контракт зависимой задачи описан в `architect_output.md`
3. Используй только публичный контракт зависимой задачи
4. Если контракт не описан — создай блокер с типом `missing-contract`

## Соблюдение архитектурных границ

- Не импортируй напрямую то, что должно приходить через DI / props / контекст
- Не создавай зависимости, которых нет на диаграмме
- Если нужна новая зависимость — пометь `TODO: [architect]`

## Чеклист перед завершением

- [ ] Реализованы только задачи из своей `task_id` в `ENGINEER_TASKS`?
- [ ] Работа велась только с файлами из `files_scope`?
- [ ] Типы и контракты из `architect_output.md` соблюдены точно?
- [ ] Нет зависимостей, которых нет на диаграмме?
- [ ] DI/props/контекст используется вместо прямых импортов где указано?
- [ ] Рутинные части помечены как `TODO: [developer]` с достаточным контекстом?
- [ ] Все неясности зафиксированы как `TODO: [architect]` или как блокер?
- [ ] При наличии `dependencies` — использован только публичный контракт зависимой задачи?
