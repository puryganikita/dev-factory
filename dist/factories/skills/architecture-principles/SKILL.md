---
name: architecture-principles
description: Архитектурные принципы (SOLID, IoC/DI, слоёная архитектура), работа с диаграммами, инварианты конвейера. Применять при архитектурном проектировании, ревью архитектуры, анализе зависимостей, создании или разборе диаграмм, разметке ENGINEER_TASKS. Универсальный скилл — активен для любого TASK_DOMAIN.
---

# Архитектурные принципы и диаграммы

## SOLID

| Принцип | Суть | Применение |
|---------|------|------------|
| **S** — Single Responsibility | Один модуль/класс/компонент — одна причина для изменения | Если класс меняется по двум причинам — разделяй |
| **O** — Open/Closed | Открыт для расширения, закрыт для модификации | Новая логика — через новые сущности, не правку старых |
| **L** — Liskov Substitution | Подтип полностью заменяем базовым типом | Переопределение не должно ломать контракт родителя |
| **I** — Interface Segregation | Много специализированных интерфейсов лучше одного универсального | Клиент не должен зависеть от методов, которые не использует |
| **D** — Dependency Inversion | Модули верхнего уровня не зависят от нижнего; оба зависят от абстракций | Зависимость на интерфейс, не на реализацию |

## IoC и инверсия зависимостей

- **IoC (Inversion of Control)** — создание и жизненный цикл объектов передаётся контейнеру
- **DI (Dependency Injection)** — реализация IoC: зависимости передаются снаружи, не создаются внутри
- **Правило**: модуль объявляет интерфейс зависимости, контейнер/вызывающий код предоставляет реализацию

```typescript
// Правильно: зависимость через интерфейс (frontend)
class OrderService {
  constructor(private repo: IOrderRepository) {}
}

// Неправильно: прямая зависимость на реализацию
class OrderService {
  private repo = new PostgresOrderRepository();
}
```

```typescript
// Правильно: зависимость через интерфейс (backend — NestJS)
@Injectable()
class PaymentService {
  constructor(
    @Inject(PAYMENT_GATEWAY) private gateway: IPaymentGateway,
    @Inject(ORDER_REPO) private orderRepo: IOrderRepository,
  ) {}
}

// Неправильно: прямая зависимость
@Injectable()
class PaymentService {
  private gateway = new StripeGateway();
}
```

## Архитектурные правила

1. Каждый слой общается только с соседним слоем — не перепрыгивает
2. Бизнес-логика не зависит от UI и инфраструктуры (фреймворков, БД, HTTP)
3. Зависимости всегда направлены внутрь (к домену), никогда наружу
4. Если паттерн уже установлен в проекте — следуй ему; новый паттерн только с явным обоснованием

### Направление зависимостей

```mermaid
graph LR
  UI["UI / API"] --> App["Application"] --> Domain["Domain"]
  Infra["Infrastructure"] --> Domain
```

## Работа с диаграммами

### Чтение диаграмм

Принимай диаграммы в любом формате: PNG, SVG, Mermaid, PlantUML, draw.io XML, ASCII.

При анализе изображений (PNG/SVG) извлекай:
- Компоненты и их границы
- Связи и направления зависимостей
- Слои и группировки
- Протоколы взаимодействия (sync/async, HTTP/gRPC/events)

### Создание диаграмм

- Предпочтительный формат — **Mermaid** (если не указан другой)
- Диаграмма отражает **реальные** зависимости (проверяй по коду), а не желаемые

| Ситуация | Тип диаграммы |
|----------|---------------|
| Компоненты и зависимости | `graph TD` / `graph LR` |
| Поток данных / запроса | `sequenceDiagram` |
| Состояния объекта | `stateDiagram-v2` |
| Структура классов | `classDiagram` |
| Процесс деплоя / CI | `flowchart` |

## Применение в конвейере

Архитектор формирует блоки `ENGINEER_TASKS` и `DEVELOPER_TASKS` в `architect_output.md`.
Оркестратор использует эти блоки для параллельного dispatch инженеров и разработчиков.

### Инварианты конвейера

- Каждый инженер работает **строго в границах `files_scope`** своей `task_id`
- Зависимости между task_id описываются через `dependencies: [id]`
- Если инженер обнаруживает невыполнимость — создаёт `*_blocker.md`
- Задачи с `dependencies: []` запускаются параллельно

### Правила разметки ENGINEER_TASKS

```yaml
- task_id: user-auth
  description: Реализовать хук useAuth
  complexity: high
  dependencies: []
  files_scope: [src/hooks/useAuth.ts, src/services/authService.ts]
```

- `task_id` — уникальный идентификатор в kebab-case
- `dependencies: []` — задача независима
- `files_scope` — границы работы инженера; выход за них — повод для блокера
- Старайся минимизировать зависимости для максимального параллелизма

## Чеклист при проектировании

- [ ] Зависимости направлены внутрь (к домену)?
- [ ] Бизнес-логика изолирована от инфраструктуры?
- [ ] Интерфейсы специализированы (ISP)?
- [ ] Новые модули расширяют систему, а не модифицируют существующие (OCP)?
- [ ] Решение вписывается в существующие паттерны проекта?
- [ ] Диаграмма соответствует реальному коду?
- [ ] Задачи в ENGINEER_TASKS максимально независимы?
- [ ] Каждый files_scope не пересекается с другими task_id?
